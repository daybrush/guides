<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>packages/react-guides/src/react-guides/Guides.tsx - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/daybrush.css">
    <link type="text/css" rel="stylesheet" href="styles/custom.css">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <meta name="description" content="packages/react-guides/src/react-guides/Guides.tsx - Documentation"/>

</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h2 class="custom"><a href="https://github.com/daybrush/guides" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><div class="search"><div class="input-area"><input type="text"/></div><button></button></div><ul class="classes"><li file="guides" class="parent"><a href="Guides.html">Guides</a><h4><a href="Guides.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="Guides.html#destroy">destroy</a></li><li data-type='method'><a href="Guides.html#emit">emit</a></li><li data-type='method'><a href="Guides.html#getGuides">getGuides</a></li><li data-type='method'><a href="Guides.html#loadGuides">loadGuides</a></li><li data-type='method'><a href="Guides.html#off">off</a></li><li data-type='method'><a href="Guides.html#on">on</a></li><li data-type='method'><a href="Guides.html#once">once</a></li><li data-type='method'><a href="Guides.html#resize">resize</a></li><li data-type='method'><a href="Guides.html#scroll">scroll</a></li><li data-type='method'><a href="Guides.html#scrollGuides">scrollGuides</a></li><li data-type='method'><a href="Guides.html#setState">setState</a></li><li data-type='method'><a href="Guides.html#trigger">trigger</a></li></ul><h4><a href="Guides.html#events">Events</a></h4><ul class='events'><li data-type='event'><a href="Guides.html#.event:changeGuides">changeGuides</a></li><li data-type='event'><a href="Guides.html#.event:drag">drag</a></li><li data-type='event'><a href="Guides.html#.event:dragEnd">dragEnd</a></li><li data-type='event'><a href="Guides.html#.event:dragStart">dragStart</a></li></ul><h4><a href="Guides.html#type definitions">Type Definitions</a></h4><ul class='type definitions'><li data-type='typddef'><a href="Guides.html#.GuideOptions">GuideOptions</a></li><li data-type='typddef'><a href="Guides.html#.GuidesEvents">GuidesEvents</a></li><li data-type='typddef'><a href="Guides.html#.GuidesInterface">GuidesInterface</a></li><li data-type='typddef'><a href="Guides.html#.GuidesOptions">GuidesOptions</a></li><li data-type='typddef'><a href="Guides.html#.GuidesProps">GuidesProps</a></li><li data-type='typddef'><a href="Guides.html#.OnChangeGuides">OnChangeGuides</a></li><li data-type='typddef'><a href="Guides.html#.OnDrag">OnDrag</a></li><li data-type='typddef'><a href="Guides.html#.OnDragEnd">OnDragEnd</a></li><li data-type='typddef'><a href="Guides.html#.OnDragStart">OnDragStart</a></li></ul></li><li file="eventemitter" class="parent"><a href="EventEmitter.html">EventEmitter</a><h4><a href="EventEmitter.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="EventEmitter.html#emit">emit</a></li><li data-type='method'><a href="EventEmitter.html#off">off</a></li><li data-type='method'><a href="EventEmitter.html#on">on</a></li><li data-type='method'><a href="EventEmitter.html#once">once</a></li><li data-type='method'><a href="EventEmitter.html#trigger">trigger</a></li><li data-type='method'><a href="EventEmitter.html#trigger">trigger</a></li></ul><h4><a href="EventEmitter.html#type definitions">Type Definitions</a></h4><ul class='type definitions'><li data-type='typddef'><a href="EventEmitter.html#.EmitterParam">EmitterParam</a></li><li data-type='typddef'><a href="EventEmitter.html#.EventHash">EventHash</a></li><li data-type='typddef'><a href="EventEmitter.html#.EventInfo">EventInfo</a></li><li data-type='typddef'><a href="EventEmitter.html#.EventListener">EventListener</a></li><li data-type='typddef'><a href="EventEmitter.html#.EventOptions">EventOptions</a></li><li data-type='typddef'><a href="EventEmitter.html#.OnEvent">OnEvent</a></li><li data-type='typddef'><a href="EventEmitter.html#.TargetParam">TargetParam</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">packages/react-guides/src/react-guides/Guides.tsx</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as React from "react";
import Ruler, { PROPERTIES as RULER_PROPERTIES, RulerProps } from "@scena/react-ruler";
import { ref, refs } from "framework-utils";
import Gesto, { OnDragEnd } from "gesto";
import styled, { StyledElement } from "react-css-styled";
import { GUIDES, GUIDE, DRAGGING, ADDER, DISPLAY_DRAG, GUIDES_CSS } from "./consts";
import { prefix } from "./utils";
import { hasClass, addClass, removeClass } from "@daybrush/utils";
import { GuidesState, GuidesProps, GuidesInterface } from "./types";
import { getDistElementMatrix, calculateMatrixDist } from "css-to-mat";

const GuidesElement = styled("div", GUIDES_CSS);

export default class Guides extends React.PureComponent&lt;GuidesProps, GuidesState> implements GuidesInterface {
    public static defaultProps: GuidesProps = {
        className: "",
        type: "horizontal",
        zoom: 1,
        style: {},
        snapThreshold: 5,
        snaps: [],
        digit: 0,
        onChangeGuides: () => { },
        onDragStart: () => { },
        onDrag: () => { },
        onDragEnd: () => { },
        displayDragPos: false,
        dragPosFormat: v => v,
        defaultGuides: [],
        lockGuides: false,
        showGuides: true,
        guideStyle: {},
        dragGuideStyle: {},
        portalContainer: null,
    };
    public state: GuidesState = {
        guides: [],
    };
    public adderElement!: HTMLElement;
    public scrollPos: number = 0;
    public ruler!: Ruler;
    private manager!: StyledElement&lt;HTMLElement>;
    private guidesElement!: HTMLElement;
    private displayElement!: HTMLElement;
    private originElement!: HTMLElement;
    private gesto!: Gesto;
    private guideElements: HTMLElement[] = [];

    public render() {
        const {
            className,
            type,
            zoom,
            style,
            rulerStyle,
            displayDragPos,
            cspNonce,
            dragGuideStyle,
            portalContainer,
        } = this.props as Required&lt;GuidesProps>;
        const props = this.props;
        const translateName = this.getTranslateName();


        const rulerProps: RulerProps = {};

        RULER_PROPERTIES.forEach(name => {
            if (name === "style") {
                return;
            }
            (rulerProps as any)[name] = props[name];
        });
        return &lt;GuidesElement
            ref={ref(this, "manager")}
            cspNonce={cspNonce}
            className={`${prefix("manager", type)} ${className}`}
            portalContainer={portalContainer}
            style={style}
        >
            &lt;div className={prefix("guide-origin")} ref={ref(this, "originElement")}>&lt;/div>
            &lt;Ruler
                ref={ref(this, "ruler")}
                style={rulerStyle}
                {...rulerProps}
            />
            &lt;div className={GUIDES} ref={ref(this, "guidesElement")} style={{
                transform: `${translateName}(${-this.scrollPos * zoom}px)`,
            }}>
                {displayDragPos &amp;&amp; &lt;div className={DISPLAY_DRAG}
                    ref={ref(this, "displayElement")} style={dragGuideStyle} />}
                &lt;div className={ADDER} ref={ref(this, "adderElement")} />
                {this.renderGuides()}
            &lt;/div>
        &lt;/GuidesElement>;
    }
    public renderGuides() {
        const {
            type,
            zoom,
            showGuides,
            guideStyle,
        } = this.props as Required&lt;GuidesProps>;
        const translateName = this.getTranslateName();
        const guides = this.state.guides;

        this.guideElements = [];
        if (showGuides) {
            return guides.map((pos, i) => {
                return (&lt;div className={prefix("guide", type)}
                    ref={refs(this, "guideElements", i)}
                    key={i}
                    data-index={i}
                    data-pos={pos}
                    style={{
                        ...guideStyle,
                        transform: `${translateName}(${pos * zoom}px) translateZ(0px)`,
                    }}>&lt;/div>);
            });
        }
        return;
    }
    public componentDidMount() {
        this.gesto = new Gesto(this.manager.getElement(), {
            container: document.body,
        }).on("dragStart", e => {
            const {
                type,
                zoom,
                lockGuides,
            } = this.props;

            if (lockGuides === true) {
                e.stop();
                return;
            }
            const inputEvent = e.inputEvent;
            const target = inputEvent.target;
            const datas = e.datas;
            const canvasElement = this.ruler.canvasElement;
            const guidesElement = this.guidesElement;
            const isHorizontal = type === "horizontal";
            const originRect = this.originElement.getBoundingClientRect();
            const matrix = getDistElementMatrix(this.manager.getElement());
            const offsetPos = calculateMatrixDist(matrix, [
                e.clientX - originRect.left,
                e.clientY - originRect.top,
            ]);
            offsetPos[0] -= guidesElement.offsetLeft;
            offsetPos[1] -= guidesElement.offsetTop;
            offsetPos[isHorizontal ? 1 : 0] += this.scrollPos * zoom!;

            datas.offsetPos = offsetPos;
            datas.matrix = matrix;

            let isLockAdd = lockGuides &amp;&amp; lockGuides.indexOf("add") > -1;
            let isLockRemove = lockGuides &amp;&amp; lockGuides.indexOf("remove") > -1;
            let isLockChange = lockGuides &amp;&amp; lockGuides.indexOf("change") > -1;

            if (target === canvasElement) {
                if (isLockAdd) {
                    e.stop();
                    return;
                }
                datas.fromRuler = true;
                datas.target = this.adderElement;
                // add
            } else if (hasClass(target, GUIDE)) {
                if (isLockRemove &amp;&amp; isLockChange) {
                    e.stop();
                    return;
                }
                datas.target = target;
                // change
            } else {
                e.stop();
                return false;
            }
            this.onDragStart(e);
        }).on("drag", this.onDrag).on("dragEnd", this.onDragEnd);
        this.setState({ guides: this.props.defaultGuides || [] }); // pass array of guides on mount data to create gridlines or something like that in ui
    }
    public componentWillUnmount() {
        this.gesto.unset();
    }
    public componentDidUpdate(prevProps: any) {
        if (prevProps.defaultGuides !== this.props.defaultGuides) {
            // to dynamically update guides from code rather than dragging guidelines
            this.setState({ guides: this.props.defaultGuides || [] });
        }
    }
    /**
     * Load the current guidelines.
     * @memberof Guides
     * @instance
     */
    public loadGuides(guides: number[]) {
        this.setState({
            guides,
        });
    }
    /**
     * Get current guidelines.
     * @memberof Guides
     * @instance
     */
    public getGuides(): number[] {
        return this.state.guides;
    }
    /**
     * Scroll the positions of the guidelines opposite the ruler.
     * @memberof Guides
     * @instance
     */
    public scrollGuides(pos: number) {
        const { zoom } = this.props as Required&lt;GuidesProps>;
        const guidesElement = this.guidesElement;

        this.scrollPos = pos;
        guidesElement.style.transform = `${this.getTranslateName()}(${-pos * zoom}px)`;

        const guides = this.state.guides;
        this.guideElements.forEach((el, i) => {
            if (!el) {
                return;
            }
            el.style.display = -pos + guides[i] &lt; 0 ? "none" : "block";
        });
    }
    /**
     * Recalculate the size of the ruler.
     * @memberof Guides
     * @instance
     */
    public resize() {
        this.ruler.resize();
    }
    /**
     * Scroll the position of the ruler.
     * @memberof Guides
     * @instance
     */
    public scroll(pos: number) {
        this.ruler.scroll(pos);
    }
    private onDragStart = (e: any) => {
        const { datas, inputEvent } = e;
        const { onDragStart } = this.props;

        addClass(datas.target, DRAGGING);
        this.onDrag(e);

        /**
         * When the drag starts, the dragStart event is called.
         * @memberof Guides
         * @event dragStart
         * @param {OnDragStart} - Parameters for the dragStart event
         */
        onDragStart!({
            ...e,
            dragElement: datas.target,
        });
        inputEvent.stopPropagation();
        inputEvent.preventDefault();
    }
    private onDrag = (e: any) => {
        const nextPos = this.movePos(e);

        /**
         * When dragging, the drag event is called.
         * @memberof Guides
         * @event drag
         * @param {OnDrag} - Parameters for the drag event
         */
        this.props.onDrag!({
            ...e,
            dragElement: e.datas.target,
        });
        return nextPos;
    }
    private onDragEnd = (e: OnDragEnd) => {
        const { datas, isDouble, distX, distY } = e;
        const pos = this.movePos(e);
        let guides = this.state.guides;
        const { onChangeGuides, zoom, displayDragPos, digit, lockGuides } = this.props;
        const guidePos = parseFloat((pos / zoom!).toFixed(digit || 0));

        if (displayDragPos) {
            this.displayElement.style.cssText += `display: none;`;
        }
        removeClass(datas.target, DRAGGING);
        /**
         * When the drag finishes, the dragEnd event is called.
         * @memberof Guides
         * @event dragEnd
         * @param {OnDragEnd} - Parameters for the dragEnd event
         */
        this.props.onDragEnd!({
            ...e,
            dragElement: datas.target,
        });
        /**
        * The `changeGuides` event occurs when the guideline is added / removed / changed.
        * @memberof Guides
        * @event changeGuides
        * @param {OnChangeGuides} - Parameters for the changeGuides event
        */
        if (datas.fromRuler) {
            if (pos >= this.scrollPos &amp;&amp; guides.indexOf(guidePos) &lt; 0) {
                this.setState({
                    guides: [...guides, guidePos],
                }, () => {
                    onChangeGuides!({
                        guides: this.state.guides,
                        distX,
                        distY,
                        isAdd: true,
                        isRemove: false,
                        isChange: false,
                    });
                });
            }
        } else {
            const index = datas.target.getAttribute("data-index");
            let isRemove = false;
            let isChange = false;

            guides = [...guides];

            if (isDouble || guidePos &lt; this.scrollPos) {
                if (lockGuides &amp;&amp; (lockGuides === true || lockGuides.indexOf("remove") > -1)) {
                    return;
                }
                guides.splice(index, 1);
                isRemove = true;
            } else if (guides.indexOf(guidePos) > -1) {
                return;
            } else {
                if (lockGuides &amp;&amp; (lockGuides === true || lockGuides.indexOf("change") > -1)) {
                    return;
                }
                guides[index] = guidePos;
                isChange = true;
            }
            this.setState({
                guides,
            }, () => {
                const nextGuides = this.state.guides;
                onChangeGuides!({
                    distX,
                    distY,
                    guides: nextGuides,
                    isAdd: false,
                    isChange,
                    isRemove,
                });
            });
        }
    }
    private movePos(e: any) {
        const { datas, distX, distY } = e;
        const props = this.props;
        const {
            type, zoom, snaps, snapThreshold,
            displayDragPos,
            digit,
        } = props;
        const dragPosFormat = props.dragPosFormat || (v => v);
        const isHorizontal = type === "horizontal";
        const matrixPos = calculateMatrixDist(datas.matrix, [distX, distY]);
        const offsetPos = datas.offsetPos;
        const offsetX = matrixPos[0] + offsetPos[0];
        const offsetY = matrixPos[1] + offsetPos[1];
        let nextPos = Math.round(isHorizontal ? offsetY : offsetX);
        let guidePos = parseFloat((nextPos / zoom!).toFixed(digit || 0));
        const guideSnaps = snaps!.slice().sort((a, b) => {
            return Math.abs(guidePos - a) - Math.abs(guidePos - b);
        });

        if (guideSnaps.length &amp;&amp; Math.abs(guideSnaps[0] * zoom! - nextPos) &lt; snapThreshold!) {
            guidePos = guideSnaps[0];
            nextPos = guidePos * zoom!;
        }
        if (displayDragPos) {
            const displayPos = type === "horizontal"
                ? [offsetX, nextPos]
                : [nextPos, offsetY];
            this.displayElement.style.cssText += `display: block;`
                + `transform: translate(-50%, -50%) `
                + `translate(${displayPos.map(v => `${v}px`).join(", ")})`;
            this.displayElement.innerHTML = `${dragPosFormat!(guidePos)}`;
        }
        datas.target.setAttribute("data-pos", guidePos);
        datas.target.style.transform = `${this.getTranslateName()}(${nextPos}px)`;

        return nextPos;

    }
    private getTranslateName() {
        return this.props.type === "horizontal" ? "translateY" : "translateX";
    }
}
</code></pre>
        </article>
    </section>





<style>


nav li[file="packages/react-guides/src/react-guides/guides"]:after {
    display: none;
}
nav li[file="packages/react-guides/src/react-guides/guides"] h4, nav li[file="packages/react-guides/src/react-guides/guides"] ul {
    display: block;
}
</style>

</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/daybrush/jsdoc">JSDoc 0.3.9</a> on Mon Apr 05 2021 02:23:42 GMT+0900 (대한민국 표준시) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/utils.min.js"></script>
<script src="scripts/search.js"></script>
<script src="scripts/custom.js"></script>
</body>
</html>
